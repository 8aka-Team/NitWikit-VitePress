import{_ as d,c as e,a5 as a,o}from"./chunks/framework.Dzz2jpra.js";const p=JSON.parse('{"title":"Command.yml","description":"","frontmatter":{"title":"Command.yml","sidebar_position":6},"headers":[],"relativePath":"nitwikit/docs-java/advance/command.yml.md","filePath":"nitwikit/docs-java/advance/command.yml.md","lastUpdated":1730968765000}'),s={name:"nitwikit/docs-java/advance/command.yml.md"};function i(c,t,n,r,l,m){return o(),e("div",null,t[0]||(t[0]=[a(`<h1 id="command-yml-介绍" tabindex="-1">Command.yml 介绍 <a class="header-anchor" href="#command-yml-介绍" aria-label="Permalink to &quot;Command.yml 介绍&quot;">​</a></h1><p>commands.yml 是一个配置文件，用于为 CraftBukkit 服务器定义自定义命令和命令方块覆盖。</p><p>命令覆盖系统可强制服务器对特定命令方块使用 Mojang 提供的命令，而别名系统允许管理员定义自定义命令并强制使用特定版本的命令。</p><h1 id="命令覆盖系统" tabindex="-1">命令覆盖系统 <a class="header-anchor" href="#命令覆盖系统" aria-label="Permalink to &quot;命令覆盖系统&quot;">​</a></h1><p>Bukkit 在默认情况下提供了一个命令覆盖系统。</p><h2 id="优先级" tabindex="-1">优先级 <a class="header-anchor" href="#优先级" aria-label="Permalink to &quot;优先级&quot;">​</a></h2><p>Aliases(自定义命令)＞ Plugin Commands(插件命令)＞ Bukkit Commands(Bukkit 命令)＞ Mojang Commands(Mojang 命令)。</p><p>Aliases(定义命令)：具有最高优先级，会覆盖所有命令。这意味着如果存在与某个命令匹配的别名，服务器将优先执行该别名所定义的命令。</p><p>Plugin Commands(插件命令)：如果没有找到匹配的命令，服务器会查找匹配的插件命令并使用它。</p><p>Bukkit Commands(Bukkit 命令)：如果没有找到匹配的插件命令，服务器将使用 Bukkit 提供的内置命令。</p><p>Mojang Commands(Mojang 命令)：如果没有找到匹配的 Bukkit 命令，作为最后一个回退选项，服务器将使用 Mojang 提供的内置命令。</p><p>每个 fallback 都有相应的权限控制，除插件命令外，Bukkit 命令的权限为 <code>bukkit.command.*</code>，Mojang 命令的权限为 <code>minecraft.command.*</code></p><h1 id="command-yml-内容" tabindex="-1">Command.yml 内容 <a class="header-anchor" href="#command-yml-内容" aria-label="Permalink to &quot;Command.yml 内容&quot;">​</a></h1><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">command-block-overrides</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: []</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">aliases</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    icanhasbukkit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;version $1-&quot;</span></span></code></pre></div><h2 id="关于-command-block-overrides-部分" tabindex="-1">关于 command-block-overrides 部分 <a class="header-anchor" href="#关于-command-block-overrides-部分" aria-label="Permalink to &quot;关于 command-block-overrides 部分&quot;">​</a></h2><p>表明当前没有对命令方块的覆盖进行设置。 这个部分的作用是控制命令方块覆盖功能。在 Bukkit 的历史中，曾提供过一些与 Minecraft 原本不同版本的命令。通过这个设置，可以强制服务器专门为命令方块使用 Mojang 提供的版本的命令 (MC 原版命令)。 而在命令方块之外使用的命令，将按照正常情况使用 Bukkit(或插件)版本的命令。</p><p><strong>命令覆盖：</strong></p><p>当你需要命令方块执行 Mojang 命令 (MC 原版命令) 而不是被插件覆盖的命令覆盖时，您可以将这个命令加入到 <code>command-block-overrides</code> 中，以下使用 give 命令举例 :</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">command-block-overrides</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;give&quot;</span></span></code></pre></div><p>当在 Essentitals 插件加载时在命令方块中的实现效果将会是 <code>minecraft:give</code> 而不是 <code>essentials:give</code></p><p>当你需要命令方块执行大量 Mojang 命令 (MC 原版命令) 而不被插件等覆盖时，您可以将这个命令加入到 <code>command-block-overrides</code> 中，以下指令会覆盖命令方块中所有的命令使用 MC 原版命令 :</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">command-block-overrides</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    - </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*&quot;</span></span></code></pre></div><h3 id="关于-aliases-部分" tabindex="-1">关于 aliases 部分 <a class="header-anchor" href="#关于-aliases-部分" aria-label="Permalink to &quot;关于 aliases 部分&quot;">​</a></h3><p>在这个配置中，定义了一个自定义命令为 <code>icanhasbukkit</code> 。 对应的命令为&quot;version $1-&quot;，这意味着当玩家输入 <code>icanhasbukkit</code> 这个命令时，实际上会执行 <code>version $1-</code> 这个命令</p><p><strong>自定义命令：</strong></p><p>这一部分允许您为服务器上的命令定义自定义命令。从本质上讲，自定义命令允许您创建可以同时执行多个功能的自定义命令。这是一个强大的工具，允许您为服务器玩家定义更容易记住的命令。</p><table tabindex="0"><thead><tr><th><strong>修饰语</strong></th><th><strong>描述</strong></th><th><strong>例子</strong></th></tr></thead><tbody><tr><td><code>$&lt;argument number&gt;</code></td><td>在一个命令结构中，当存在多个参数输入时，<code>$&lt;argument number&gt;</code> 可以根据给定的参数编号来获取对应的输入值。例如在 <code>say $1 $2 $3</code> 这个命令中，<code>$1</code>代表第一个输入的参数，<code>$2</code> 代表第二个输入的参数，<code>$3</code> 代表第三个输入的参数。如果执行该命令时输入 <code>say word1 word2 word3</code> ，那么<code>$1</code> 将被替换为 <code>word1</code>，<code>$2</code>将被替换为 <code>word2</code>，<code>$3</code> 将被替换为 <code>word3</code>。</td><td><code>say $1 $2 $3</code></td></tr><tr><td><code>$&lt;argument number&gt;-</code></td><td>在命令执行过程中，此表达式可以获取从指定参数位置开始及之后的所有参数值。例如在 <code>say $1-</code> 中，如果输入<code>say phrase1 phrase2 phrase3</code>，那么 <code>$1-</code> 将代表 <code>phrase1 phrase2 phrase3</code> 这个完整的参数序列。</td><td><code>say $1-</code></td></tr><tr><td><code>$$&lt;argument number&gt;</code></td><td>在命令设计中，这种形式强调特定位置的参数的必要性。例如 <code>say $1</code>，如果执行命令时没有为第一个位置提供参数值，那么该命令将不会被触发执行。只有当有输入值对应到第一个位置时，例如<code>say something</code>，这里 <code>$1</code> 将被替换为 <code>something</code>，命令才会正常执行。</td><td><code>say $$1</code></td></tr><tr><td><code>$$&lt;argument number&gt;-</code></td><td>与前面的解释类似，但涉及到一个参数范围。例如在 <code>say $1-</code> 中，如果输入 <code>say onlyword</code>，由于只有一个参数且该参数对应第一个位置，但是这里要求起始参数必须有值且后面还有其他参数才满足条件，所以这个命令不会执行。而如果输入 <code>say start second third</code>，从第一个参数 <code>start</code> 开始到后面的参数都有值，满足条件，此时 <code>$1-</code> 将代表 <code>start second third</code> 这个参数序列。</td><td><code>say $$1-</code></td></tr><tr><td>\\</td><td>在一些命令语法中，某些字符被赋予了特定的功能含义，比如 <code>$</code> 通常用于参数引用。但当我们希望这个字符不作为特殊功能字符，而仅仅作为普通字符出现时，就可以使用 <code>\\</code> 进行转义。例如在<code>say $100</code> 中，<code>$</code> 使得 <code>““</code> 失去了参数引用的特殊含义，而仅作为字符出现</td><td><code>say \\$100</code></td></tr></tbody></table><table tabindex="0"><thead><tr><th><strong>场景</strong></th><th><strong>描述</strong></th><th><strong>命令用法</strong></th><th><strong>示例配置</strong></th></tr></thead><tbody><tr><td>添加运行 /version 命令的替代方法</td><td>通过注册一个名为 <code>icanhasbukkit</code> 的自定义命令，在使用该自定义命令时会执行 version 命令，从而提供了一种运行 /version 命令的替代方式。</td><td>输入 <code>/icanhasbukkit</code></td><td>aliases:<br> icanhasbukkit:<br> - &quot;version&quot;</td></tr><tr><td>删除命令</td><td>注册一个名为 <code>summon</code> 的自定义命令并将其映射到空列表，以此告诉服务器取消注册该命令，防止其存在和发挥作用。</td><td>无特定命令输入示例，因为目的是删除命令</td><td>aliases:<br> summon:<br> - []</td></tr><tr><td>重命名 /version 命令</td><td>注册一个名为 <code>icanhasversion</code> 的自定义命令来执行 version 命令，同时创建一个名为 “version” 的自定义命令并映射到空列表以删除原有的 /version 命令。</td><td>输入 <code>/icanhasversion</code></td><td>aliases:<br> icanhasversion:<br> - &quot;bukkit:version&quot;<br> version:<br> - []</td></tr><tr><td>需要参数</td><td>创建一个名为 <code>givedirt</code> 的自定义命令，该自定义命令需要提供一个参数(这里是玩家的名字)才能成功运行。</td><td>输入 <code>/givedirt &lt;player&gt;</code>，其中 <code>&lt;player&gt;</code> 为玩家名称</td><td>aliases:<br> givedirt:<br> - &quot;give $$1 minecraft:dirt\`</td></tr><tr><td>运行多个命令</td><td>创建一个名为 <code>givedirtmsg</code> 的自定义命令，该自定义命令会在成功运行前执行两个需要参数的命令。</td><td>输入 <code>/givedirtmsg &lt;player&gt;</code>，其中 <code>&lt;player&gt;</code> 为玩家名称</td><td>aliases:<br> givedirtmsg:<br> - &quot;give $$1 minecraft:dirt&quot;<br> - &quot;say Gave dirt to $$1&quot;</td></tr><tr><td>使用插件提供的命令</td><td>通过自定义命令覆盖内置的 <code>/time</code> 命令，使用插件 ScrapBukkit 提供的版本。</td><td>输入 <code>/time &lt;set|add&gt; &lt;value&gt;</code></td><td>aliases:<br> time:<br> - &quot;scrapbukkit:time $1-&quot;</td></tr><tr><td>使用 Mojang 提供的命令</td><td>通过自定义命令覆盖内置的 <code>/time</code> 命令，使用 Mojang 提供的版本。</td><td>输入 <code>/time &lt;set|add&gt; &lt;value&gt;</code></td><td>aliases:<br> time:<br> - &quot;minecraft:time $1-&quot;</td></tr><tr><td>使用 Bukkit 提供的命令</td><td>通过自定义命令覆盖内置的 <code>/time</code> 命令，使用 Bukkit 提供的版本。</td><td>输入 <code>/time &lt;set|add&gt; &lt;value&gt;</code></td><td>aliases:<br> time:<br> - &quot;bukkit:time $1-&quot;</td></tr><tr><td>接受所有参数</td><td>创建一个名为 <code>broadcast</code> 的自定义命令，该自定义命令将执行 <code>say</code> 命令并接受传递给它的任何参数。</td><td>输入 <code>/broadcast &lt;message&gt;</code>，其中 <code>&lt;message&gt;</code> 为要广播的消息。</td><td>aliases:<br> broadcast:<br> - &quot;say $$1-&quot;</td></tr><tr><td>需要第一个参数，同时使第二个参数可选</td><td>覆盖内置的 <code>ban</code> 命令，这个自定义命令需要第一个参数(这里是玩家的名字)，同时支持可选的封禁理由。当使用该自定义命令时，玩家将被封禁，并广播一条消息通知服务器上的其他人有人被封禁了。</td><td>输入 <code>/ban &lt;player&gt; [optional reason]</code>，其中 <code>&lt;player&gt;</code> 为玩家名称，<code>[optional reason]</code> 为可选的封禁理由</td><td>aliases:<br> ban:<br> - &quot;bukkit:ban $$1 $2-&quot;<br> - &quot;say Banned $$1. Reason: $2-&quot;</td></tr><tr><td>在命令中使用$符号</td><td>创建一个名为 <code>dollar</code> 的自定义命令，该自定义命令会向服务器广播消息 “That will be 200，thanks！&#39;&#39; 由于字符用于表示参数，所以在创建自定义命令时需要用反斜杠(\\)对其进行转义。</td><td>输入 <code>/dollar</code></td><td>aliases:<br> dollar:<br> - &quot;say That will be \\$200， thanks!&quot;</td></tr></tbody></table>`,28)]))}const k=d(s,[["render",i]]);export{p as __pageData,k as default};
