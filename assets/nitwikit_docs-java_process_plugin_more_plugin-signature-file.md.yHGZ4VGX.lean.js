import{_ as a,c as o,a5 as i,o as r}from"./chunks/framework.O9ad3XaM.js";const d="/assets/%E6%8B%86%E5%BC%80jar.BDhF-ZPJ.png",t="/assets/plugin.yml.Dvm84_QT.png",b=JSON.parse('{"title":"特征文件","description":"","frontmatter":{"title":"特征文件","sidebar_position":3},"headers":[],"relativePath":"nitwikit/docs-java/process/plugin/more/plugin-signature-file.md","filePath":"nitwikit/docs-java/process/plugin/more/plugin-signature-file.md","lastUpdated":1730488911000}'),s={name:"nitwikit/docs-java/process/plugin/more/plugin-signature-file.md"};function l(n,e,p,c,h,u){return r(),o("div",null,e[0]||(e[0]=[i('<h1 id="plugin-yml" tabindex="-1">plugin.yml <a class="header-anchor" href="#plugin-yml" aria-label="Permalink to &quot;plugin.yml&quot;">​</a></h1><p>用解压缩软件打开插件的jar文件就可以看到 <code>plugin.yml</code>：</p><p><img src="'+d+'" alt=""></p><p>用文本编辑器可以打开它：</p><p><img src="'+t+'" alt=""></p><p>其实只有 <code>name</code> 和 <code>main</code> 是必填的，其他可写可不写。</p><p>比如一个插件有提供命令，但它不在 <code>plugin.yml</code> 中写 <code>commands</code> 也是很常见的。</p><h2 id="常见的键" tabindex="-1">常见的键 <a class="header-anchor" href="#常见的键" aria-label="Permalink to &quot;常见的键&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>其实这里面写什么都可以，但多数就那么几样...</p></div><p>下面是常见的一些键值：</p><h2 id="name" tabindex="-1"><code>name</code> <a class="header-anchor" href="#name" aria-label="Permalink to &quot;`name`&quot;">​</a></h2><p>插件的名字，也是会在插件列表(<code>/pl</code>)和日志中输出的信息中显示的插件名。</p><h2 id="version" tabindex="-1"><code>version</code> <a class="header-anchor" href="#version" aria-label="Permalink to &quot;`version`&quot;">​</a></h2><p>插件版本，显示在 <code>/version 插件名</code> 中。</p><h2 id="main" tabindex="-1"><code>main</code> <a class="header-anchor" href="#main" aria-label="Permalink to &quot;`main`&quot;">​</a></h2><p>插件主类，加载插件时运行的类的名称，类似正常程序中的 main 函数，服主不用管。</p><h2 id="description" tabindex="-1"><code>description</code> <a class="header-anchor" href="#description" aria-label="Permalink to &quot;`description`&quot;">​</a></h2><p>简短描述插件的作用，会在 <code>/pl</code> 命令中鼠标悬浮在插件名称上时显示。</p><h2 id="authors" tabindex="-1"><code>authors</code> <a class="header-anchor" href="#authors" aria-label="Permalink to &quot;`authors`&quot;">​</a></h2><p>插件作者，显示在 <code>/version 插件名</code> 中。</p><h2 id="contributors" tabindex="-1"><code>contributors</code> <a class="header-anchor" href="#contributors" aria-label="Permalink to &quot;`contributors`&quot;">​</a></h2><p>贡献者，指非作者但为插件贡献了代码的人。</p><h2 id="website" tabindex="-1"><code>website</code> <a class="header-anchor" href="#website" aria-label="Permalink to &quot;`website`&quot;">​</a></h2><p>插件相关的网站，显示在 <code>/version 插件名</code> 中。</p><h2 id="api-version" tabindex="-1"><code>api-version</code> <a class="header-anchor" href="#api-version" aria-label="Permalink to &quot;`api-version`&quot;">​</a></h2><p>插件编译时使用的 API 版本，影响着 BukkitAPI 对插件提供的兼容性。</p><h2 id="load" tabindex="-1"><code>load</code> <a class="header-anchor" href="#load" aria-label="Permalink to &quot;`load`&quot;">​</a></h2><p>这告诉服务器何时加载插件。它可以是 <code>STARTUP</code> 或 <code>POSTWORLD</code> 。 如果未指定，将默认为 <code>POSTWORLD</code>。</p><h2 id="prefix" tabindex="-1"><code>prefix</code> <a class="header-anchor" href="#prefix" aria-label="Permalink to &quot;`prefix`&quot;">​</a></h2><p>在服务器日志中显示的前缀，有别于插件名称。</p><h2 id="libraries" tabindex="-1"><code>libraries</code> <a class="header-anchor" href="#libraries" aria-label="Permalink to &quot;`libraries`&quot;">​</a></h2><p>插件的依赖库表，不过这并不是前置插件的意思，而是插件开发时用到的依赖。</p><h2 id="permissions" tabindex="-1"><code>permissions</code> <a class="header-anchor" href="#permissions" aria-label="Permalink to &quot;`permissions`&quot;">​</a></h2><p>插件权限相关。</p><h2 id="default-permission" tabindex="-1"><code>default-permission</code> <a class="header-anchor" href="#default-permission" aria-label="Permalink to &quot;`default-permission`&quot;">​</a></h2><p>默认权限。</p><h2 id="commands" tabindex="-1"><code>commands</code> <a class="header-anchor" href="#commands" aria-label="Permalink to &quot;`commands`&quot;">​</a></h2><p>插件提供的命令。</p><h2 id="dependencies" tabindex="-1">Dependencies <a class="header-anchor" href="#dependencies" aria-label="Permalink to &quot;Dependencies&quot;">​</a></h2><p><a href="https://docs.papermc.io/paper/dev/plugin-yml#dependencies" target="_blank" rel="noreferrer">依赖关系</a>。</p><h3 id="depend" tabindex="-1"><code>depend</code> <a class="header-anchor" href="#depend" aria-label="Permalink to &quot;`depend`&quot;">​</a></h3><p>硬依赖，必须安装。</p><h3 id="softdepend" tabindex="-1"><code>softdepend</code> <a class="header-anchor" href="#softdepend" aria-label="Permalink to &quot;`softdepend`&quot;">​</a></h3><p>软依赖，即不必须装的依赖。</p><h3 id="loadbefore" tabindex="-1"><code>loadbefore</code> <a class="header-anchor" href="#loadbefore" aria-label="Permalink to &quot;`loadbefore`&quot;">​</a></h3><p>在此列表中的插件加载前加载本插件。</p><h3 id="probides" tabindex="-1"><code>probides</code> <a class="header-anchor" href="#probides" aria-label="Permalink to &quot;`probides`&quot;">​</a></h3><p>告诉服务器本插件会提供哪些库或功能。</p><h2 id="folia-supported" tabindex="-1"><code>folia-supported</code> <a class="header-anchor" href="#folia-supported" aria-label="Permalink to &quot;`folia-supported`&quot;">​</a></h2><p>当此项为 <code>true</code> 时，Folia 端才会尝试加载此插件。</p><p>如果插件的 <code>plugin.yml</code> 里没有此项，你可以试着手动添加。</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">folia-supported</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>Folia 端对 Bukkit API 的修改是破坏性的，你手动添加而不是插件开发者去兼容，通常加载了也是不可用的。</p><p>这就是为什么要开启此项 Folia 端才会加载该插件。</p></div><h1 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h1><ul><li><a href="https://docs.papermc.io/paper/dev/plugin-yml" target="_blank" rel="noreferrer">https://docs.papermc.io/paper/dev/plugin-yml</a></li></ul>',55)]))}const f=a(s,[["render",l]]);export{b as __pageData,f as default};
